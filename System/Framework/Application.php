<?php/** * DreamCMS 3.0 * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU General Public License as published by * the Free Software Foundation, either version 2 of the License, or * any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU General Public License for more details. * * You should have received a copy of the GNU General Public License * along with this program. If not, see <http://www.gnu.org/licenses/>. * * PHP Version 5 * * @package      DreamCMS * @version      3.0.0 Beta * @category     Framework * @copyright    2008-2013 Marcel Domke * @license      http://www.gnu.org/licenses/gpl-2.0.txt GNU GENERAL PUBLIC LICENSE Version 2 * @author       Marcel Domke <http://www.dcms-studio.de> * @link         http://www.dcms-studio.de * @file         Application.php */class Application extends Loader{    /**     *     */    const DEFAULT_PAGEFOLDER = 0; // do not change this!    /**     *     */    const BACKEND_MODE = 1;    const FRONTEND_MODE = 0;    /**     * Application environment     *     * @var string     */    protected $_environment;    /**     * Flattened (lowercase) option keys     *     * @var array     */    protected $_optionKeys = array();    /**     * Options for Application     *     * @var array     */    protected static $_options = array();    /**     * Store all modules with permissions and definition     *     * @var array     */    protected static $_modulRegistry = null;    /**     * Store all packages     *     * @var array     */    protected $_packageRegistry = null;    protected $_packagetypes = array(        'plugin',        'skins',        'widgets'    );    /**     * all core modules     * used by Application::isActiveModul     *     * @var array     */    public $_coreModules = array(        'cache'     => true,        'widget'    => true,        'logs'      => true,        'auth'      => true,        'modules'   => true,        'tooltip'   => true,        'settings'  => true,        'help'      => true,        'personal'  => true,        'user'      => true,        'usergroup' => true,        'dashboard' => true,    );    /**     *     * @var array default is null     */    protected $_frontendModules = null;    /**     *     * @var Config     */    protected $_systemConfig;    /**     *     * @var Autoloader     */    protected $_autoloader;    /**     * @var array     */    private $_moduleNames = null;    /**     * @var int     */    protected $_applicationMode;    /**     * @var string     */    public static $charset = 'utf-8';    /**     * @var array     */    protected static $_routes = null;    private static $_isBackend = false;    /**     * Constructor     *     * Initialize application. Potentially initializes include_paths, PHP     * settings, and bootstrap class.     *     * @param string $environment     * @return \Application     */    public function __construct($environment = 'PRODUCTIV')    {        parent::__construct();        $this->_environment     = $environment;        $this->_applicationMode = ( ( defined( 'ADM_SCRIPT' ) && ADM_SCRIPT ) ? self::BACKEND_MODE : self::FRONTEND_MODE );        $this->_systemConfig    = new Config( array(), ( $this->_applicationMode === self::FRONTEND_MODE ? false : true ) );        self::$_isBackend       = $this->_applicationMode;        Registry::setObject( 'Application', $this );        // the first call after the install        if ( defined( 'FIRSTRUN' ) )        {            $this->_systemConfig->setWriteable();            SystemManager::cleanControllerActionsAfterInstall();            $this->_systemConfig->setReadOnly();        }        $requestUri = $this->Env->requestUri();        if ( !$this->_get( '_call' ) )        {            if ( substr( $requestUri, 0, 10 ) === '/Packages/' && preg_match( '#.*\.(css|js|png|jpe?g|gif|bmp|txt|html|json)$#i', $requestUri ) )            {                if ( substr( substr( $requestUri, 10 ), 0, 8 ) === 'plugins/' || substr( substr( $requestUri, 10 ), 0, 8 ) === 'widgets/' && is_file( ROOT_PATH . substr( $requestUri, 1 ) ) )                {                    readfile( ROOT_PATH . substr( $requestUri, 1 ) );                    exit;                }            }        }        Registry::setObject( 'Event', new Event() );        /**         *         */        define( 'USER_IP', $this->Env->ip() );        /**         *         */        define( 'USER_BROWSER', $this->Env->httpUserAgent() );        //define('DIR', dirname(__FILE__));        //$array = include PUBLIC_PATH . 'pages/2/.cache/data/routemap.php';        //$this->write_php_ini($array, PUBLIC_PATH. 'pages/2/.cache/data/routemap.ini');        register_shutdown_function( array(            $this,            'executeCronJobs'        ) );    }    private function write_php_ini($array, $file)    {        $res = array();        $names = array('controller', 'action', 'compiled_rule', 'params');        foreach($array as $modul => $data)        {            if(is_array($data))            {                $res[] = "";                $res[] = "[$modul]";                foreach ( $data as $dd )                {                    foreach ( $dd as $key => $val )                    {                        if (in_array($key, $names) )                        {                            if (is_string($val)) {                                $res[] = "$key = ".(is_numeric($val) ? $val : '"'.$val.'"');                            }                            elseif (is_array($val))                            {                                $res[] = "";                                $res[] = "";                                $val = array_unique($val);                                foreach ( $val as $skey => $sval ) {                                    if (is_string($skey) && is_string($sval)) {                                        $res[] = "$skey = ".(is_numeric($sval) ? $sval : '"'.$sval.'"');                                    }                                }                            }                        }                    }                }               // foreach($val as $skey => $sval) $res[] = "$skey = ".(is_numeric($sval) ? $sval : '"'.$sval.'"');            }        }        $fp = fopen($file, 'w');        fwrite($fp, implode("\r\n", $res) );        fclose($fp);    }    /**     * @return bool     */    public static function isBackend()    {        return ( self::$_isBackend === self::BACKEND_MODE ? true : false );    }    /**     * @return bool     */    public static function isFrontend()    {        return ( self::$_isBackend === self::FRONTEND_MODE ? true : false );    }    /**     *     */    public function executeCronJobs()    {        Cache::doRunShutdown();        $error = $this->input( 'error' );        if ( $this->isFrontend() && !IS_AJAX && !$error )        {            if ( ( defined( 'REQUEST' ) && !preg_match( '#(asset/|main/(lang|captcha)|track|lang)#i', REQUEST ) ) && // filter tracker, asset and lang requests                $this->Input->getMethod() != 'post'            )            {                // file_put_contents(ROOT_PATH.'track.txt', print_r($_REQUEST, true));                Tracking::track();            }        }        $this->load( 'Cronjob' );        $this->Cronjob->runCronjob();        // $this->db->close();    }    /**     * Retrieve current Application mode     *     * @return integer     */    public function getMode()    {        return $this->_applicationMode;    }    /**     * Retrieve current environment     *     * @return string     */    public function getEnvironment()    {        return $this->_environment;    }    /**     * Retrieve autoloader instance     *     * @return Autoloader     */    public function getAutoloader()    {        return $this->__autoloader;    }    /**     * Returns the Loaded System Configuration instance     *     * @return Config     */    public function getSystemConfig()    {        return $this->_systemConfig;    }    /**     *     * @param array $options     * @return Application     */    public function setOptions(array $options)    {        self::$_options = $options;        $options = array_change_key_case( $options, CASE_LOWER );        $this->_optionKeys = array_keys( $options );        return $this;    }    /**     * Retrieve application options (for caching)     *     * @return array     */    public function getOptions()    {        return self::$_options;    }    /**     * Is an option present?     *     * @param  string $key     * @return bool     */    public function hasOption($key)    {        return in_array( strtolower( $key ), $this->_optionKeys );    }    /**     * Retrieve a single option     *     * @param  string $key     * @return mixed     */    public function getOption($key)    {        if ( $this->hasOption( $key ) )        {            $options = $this->getOptions();            $options = array_change_key_case( $options, CASE_LOWER );            return $options[ strtolower( $key ) ];        }        return null;    }    /**     * Merge options recursively     *     * @param  array $array1     * @param  mixed $array2     * @return array     */    public function mergeOptions(array $array1, $array2 = null)    {        if ( is_array( $array2 ) )        {            foreach ( $array2 as $key => $val )            {                if ( is_array( $array2[ $key ] ) )                {                    $array1[ $key ] = ( isset( $array1[ $key ] ) && is_array( $array1[ $key ] ) ) ? $this->mergeOptions( $array1[ $key ], $array2[ $key ] ) : $array2[ $key ];                }                else                {                    $array1[ $key ] = $val;                }            }        }        return $array1;    }    /**     * Set PHP configuration settings     *     * @param  array $settings     * @param  string $prefix Key prefix to prepend to array values (used to map . separated INI values)     * @return Application     */    public function setPhpSettings(array $settings, $prefix = '')    {        foreach ( $settings as $key => $value )        {            $key = empty( $prefix ) ? $key : $prefix . $key;            if ( is_scalar( $value ) )            {                ini_set( $key, $value );            }            elseif ( is_array( $value ) )            {                $this->setPhpSettings( $value, $key . '.' );            }        }        return $this;    }    /**     *     * @return array     */    private function _getModules()    {        return File::getSubDir( MODULES_PATH );    }    /**     *     * @return array     */    public function getModuleNames()    {        if ( $this->_moduleNames === null )        {            $this->_moduleNames = $this->_getModules();        }        return $this->_moduleNames;    }    /**     *     * @param string $type     * @return array     */    private function _getPackages($type)    {        return File::getSubDir( PACKAGES_PATH . $type );    }    /**     *     * @return array     */    public function getPackages()    {        if ( $this->_packageRegistry === null )        {            foreach ( $this->_packagetypes as $folder )            {                $this->_packageRegistry[ $folder ] = $this->_getPackages( $folder );            }        }        return $this->_packageRegistry;    }    /**     * load all routes     *     * @return Application     */    public function initRoutes()    {        if ( is_array( self::$_routes ) )        {            return $this;        }        $tmp = Cache::get( 'routemap', 'data' );        if ( !is_array( $tmp ) )        {            $maps = $this->db->query( 'SELECT * FROM %tp%routermap ORDER BY controller, `action` ASC' )->fetchAll();            error_reporting( E_ALL );            Library::enableErrorHandling();            $tmp = array();            foreach ( $maps as $idx => $r )            {                $paramKeys = null;                $params    = null;                if ( !empty( $r[ 'optionalmap' ] ) )                {                    $parms = unserialize( $r[ 'optionalmap' ] );                    if ( isset( $parms[ 'attribute' ] ) )                    {                        $paramKeys = array();                        $params    = array();                        $i = 1;                        foreach ( $parms[ 'attribute' ] as $idx2 => $mapparam )                        {                            if ( $mapparam )                            {                                $paramKeys[ $i++ ]   = $mapparam;                                $params[ $mapparam ] = ( isset( $parms[ 'match' ][ $idx2 ] ) ? $parms[ 'match' ][ $idx2 ] : '.+' );                            }                        }                    }                }                // remove the first seperator                if ( substr( $r[ 'rule' ], 0, 1 ) === '/' )                {                    $r[ 'rule' ] = substr( $r[ 'rule' ], 1 );                }                // skip if the rule is empty                if ( $r[ 'rule' ] === '' )                {                    continue;                }                //     if ( $paramKeys !== null && $params !== null )                //     {                $tmp[ ucfirst( strtolower( $r[ 'controller' ] ) ) ][ ] = array(                    'controller' => $r[ 'controller' ],                    'action'     => ( $r[ 'action' ] ? $r[ 'action' ] : 'index' ),                    'rule'       => $r[ 'rule' ],                    'params'     => $params,                    'paramkeys'  => $paramKeys                );                //    }                /*    else                  {                  $tmp[ ucfirst( strtolower( $r[ 'controller' ] ) ) ][] = array(                  'controller' => $r[ 'controller' ],                  'action'     => ($r[ 'action' ] ? $r[ 'action' ] : 'index'),                  'rule'       => $r[ 'rule' ]                  );                  }                 */                unset( $paramKeys, $params );            }            $this->load( 'Router' );            $this->Router->compileRoules( $tmp );            Cache::write( 'routemap', $tmp, 'data' );            $this->db->free();        }        self::$_routes = $tmp;        unset( $tmp );        return $this;    }    /**     *     * @return array/null     */    public function getRouteConfig()    {        return self::$_routes;    }    /**     *     * @param string $moduleName (ucfirst)     * @return array/null     */    public function loadRouteConfig($moduleName)    {        if ( !isset( self::$_routes[ ucfirst( strtolower( $moduleName ) ) ] ) )        {            return null;        }        $_routes = self::$_routes[ ucfirst( strtolower( $moduleName ) ) ];        return $_routes;    }    /**     * return the used Memory     *     * @param boolean $returnFormated if is true then return a format e.g. 12.05 MB     * @return int|string     */    public function getUsedMemory($returnFormated = false)    {        return ( $returnFormated ? Tools::formatSize( memory_get_usage() - INIT_MEMORY ) : memory_get_usage() - INIT_MEMORY );    }    /**     * read all installed modules from database     *     * @return array     */    public function loadFrontendModules()    {        if ( !is_null( $this->_frontendModules ) )        {            return $this->_frontendModules;        }        $modules = Cache::get( 'fe_modules', 'data' );        if ( !$modules )        {            if ( !defined( 'PAGEID' ) )            {                die( 'Invalid Page ID' );            }            $mods = $this->db->query( 'SELECT * FROM %tp%module WHERE pageid = ?', PAGEID )->fetchAll();            $modules = array();            foreach ( $mods as $r )            {                $modules[ ucfirst( $r[ 'module' ] ) ] = $r;                $mod                                  = $this->getModulRegistry( $r[ 'module' ] );                if ( isset( $mod[ 'definition' ][ "modulelabel" ] ) )                {                    $modules[ ucfirst( $r[ 'module' ] ) ][ "modulelabel" ] = $mod[ 'definition' ][ "modulelabel" ];                }            }            Cache::write( 'fe_modules', $modules, 'data' );            $this->db->free();            unset( $mods );        }        $this->_frontendModules = $modules;        unset( $modules );        return $this->_frontendModules;    }    /**     * will check a modul by activation     * returns true if active and false if not active     *     * @param string $modul (ucfirst)     * @return boolean     */    public function isActiveModul($modul)    {        if ( isset( $this->_coreModules[ strtolower( $modul ) ] ) )        {            return true;        }        if ( is_null( $this->_frontendModules ) )        {            $this->loadFrontendModules();        }        return ( ( isset( $this->_frontendModules[ ucfirst( strtolower( $modul ) ) ] ) && $this->_frontendModules[ ucfirst( strtolower( $modul ) ) ][ 'published' ] ) ? true : false );    }    /**     * Delete modul registry an refresh the modul registry     *     * @return \Application     */    public function refreshModulRegistry()    {        Cache::delete( 'modul-props', 'data' );        self::$_modulRegistry = array();        $this->registerModules();        Cache::delete( 'fe_modules', 'data' );        $this->frontendModules = null;        $this->loadFrontendModules();    }    /**     * Will register all modules in the autoloader and     * store all modul permissions with modul definition     *     * @return \Application     */    protected function registerModules()    {        Hook::run( 'onBeforeRegisterModules' ); // {CONTEXT:Framework, DESC:Run code before the Application loading all modules in the autoloader and store all modul permissions with modul definition}        $modules = $this->getModuleNames();        // use for registerBackedMenu in (Modul name)_Config_Base        $this->load( 'Action' );        $this->load( 'Permission' );        $modulProps = Cache::get( 'modul-props', 'data' );        if ( !$modulProps )        {            foreach ( $modules as $module )            {                $ucModul = ucfirst( strtolower( $module ) );                $this->__autoloader                    ->addModulLibrary( $ucModul, 'Config', MODULES_PATH . $ucModul . '/Config/' )                    ->addModulLibrary( $ucModul, 'Controller', MODULES_PATH . $ucModul . '/Controller/' )                    ->addModulLibrary( $ucModul, 'Action', MODULES_PATH . $ucModul . '/Action/' )                    ->addModulLibrary( $ucModul, 'Model', MODULES_PATH . $ucModul . '/Model/' )                    ->addModulLibrary( $ucModul, 'Helper', MODULES_PATH . $ucModul . '/Helper/' )                    ->addModulLibrary( $ucModul, 'Widget', MODULES_PATH . $ucModul . '/Widgets/' );                $className = $ucModul . '_Config_Base';                $definition  = array();                $permissions = array();                // Read all permission options                if ( method_exists( $className, 'getControllerPermissions' ) /*checkClassMethod($className . '/getControllerPermissions', 'static')*/ )                {                    /**                     * Store frontent permissions                     */                    $frontendPerms = call_user_func( $className . '::getControllerPermissions', false );                    if ( is_array( $frontendPerms ) )                    {                        foreach ( $frontendPerms as $action => $value )                        {                            $permissions[ self::FRONTEND_MODE ][ $action ] = array(                                'requirelogin'      => ( $value[ 0 ] ? true : false ),                                'requirepermission' => ( $value[ 1 ] ? true : false )                            );                        }                    }                    unset( $frontendPerms );                    /**                     * Store backend permissions                     */                    $backendPerms = call_user_func( $className . '::getControllerPermissions', true );                    if ( is_array( $backendPerms ) )                    {                        foreach ( $backendPerms as $action => $value )                        {                            $permissions[ self::BACKEND_MODE ][ $action ] = array(                                'requirelogin'      => ( $value[ 0 ] ? true : false ),                                'requirepermission' => ( $value[ 1 ] ? true : false )                            );                        }                    }                    unset( $backendPerms );                }                // Read modul definitions                if ( method_exists( $className, 'getModulDefinition' ) /*checkClassMethod($className . '/getModulDefinition', 'static')*/ )                {                    $definition = call_user_func( $className . '::getModulDefinition', true );                }                if ( method_exists( $className, 'bindEvents' ) /*checkClassMethod($className . '/bindEvents', 'static')*/ )                {                    call_user_func( $className . '::bindEvents' );                }                self::$_modulRegistry[ strtolower( $module ) ] = array(                    'permissions' => $permissions,                    'definition'  => $definition                );                unset( $definition );            }            Cache::write( 'modul-props', self::$_modulRegistry, 'data' );        }        else        {            foreach ( $modules as $module )            {                $ucModul = ucfirst( strtolower( $module ) );                $this->__autoloader                    ->addModulLibrary( $ucModul, 'Config', MODULES_PATH . $ucModul . '/Config/' )                    ->addModulLibrary( $ucModul, 'Controller', MODULES_PATH . $ucModul . '/Controller/' )                    ->addModulLibrary( $ucModul, 'Action', MODULES_PATH . $ucModul . '/Action/' )                    ->addModulLibrary( $ucModul, 'Model', MODULES_PATH . $ucModul . '/Model/' )                    ->addModulLibrary( $ucModul, 'Helper', MODULES_PATH . $ucModul . '/Helper/' )                    ->addModulLibrary( $ucModul, 'Widget', MODULES_PATH . $ucModul . '/Widgets/' );                $className = $ucModul . '_Config_Base';                if ( method_exists( $className, 'bindEvents' ) /*checkClassMethod($className . '/bindEvents', 'static')*/ )                {                    call_user_func( $className . '::bindEvents' );                }            }            self::$_modulRegistry = $modulProps;        }        unset( $modules );        return $this;    }    private function registerBackendMenues()    {        foreach ( self::$_modulRegistry as $modul => $opt )        {            $ucModul   = ucfirst( $modul );            $className = $ucModul . '_Config_Base';            // register backend menu            if ( checkClassMethod( $className . '/registerBackedMenu', 'static' ) )            {                call_user_func( $className . '::registerBackedMenu' );            }        }        // Plugin::registerBackendMenues();    }    /**     *     * @param string $modul default null will return the full registry     * @return array|null     */    public function getModulRegistry($modul = null)    {        if ( is_null( self::$_modulRegistry ) )        {            $this->registerModules();        }        if ( $modul === null )        {            return self::$_modulRegistry;        }        return isset( self::$_modulRegistry[ strtolower( $modul ) ] ) ? self::$_modulRegistry[ strtolower( $modul ) ] : null;    }    /**     * get all permission keys by a modul     *     * @param string $modul     * @param integer $permissionMode (backend or frontend mode)     * @return array|null     */    public function getModulPermissionKeys($modul, $permissionMode)    {        $_permKeys = array();        $_registry = $this->getModulRegistry( $modul );        return isset( $_registry[ 'permissions' ][ $permissionMode ] ) ? $_registry[ 'permissions' ][ $permissionMode ] : null;    }    /**     *     * @todo Better Domain handling in the next Version of DreamCMS!!!     * Clean Domain name an use it for the PAGE_PATH.     *     *     * @param boolean $useMultiple     * @throws BaseException     * @return Application     */    public function setupWebsiteDomain($useMultiple = false)    {        // $this->setApplicationInstance( $this );        Hook::run( 'onBeforeSetupWebsiteByDomain' ); // {CONTEXT:Framework, DESC:Run code before setup the Website}        unset( $_SESSION );        if ( $useMultiple )        {            $host = !empty( $_SERVER[ 'SERVER_ADDR' ] ) ? $_SERVER[ 'SERVER_ADDR' ] : false;            $host = !empty( $_SERVER[ 'SERVER_NAME' ] ) ? $_SERVER[ 'SERVER_NAME' ] : $host;            $host = !empty( $_SERVER[ 'HTTP_HOST' ] ) ? $_SERVER[ 'HTTP_HOST' ] : $host;            $domain = ( $host ? preg_replace( '/^www\./i', '', $host ) : false );            if ( empty( $domain ) )            {                throw new BaseException( 'Multi-domain support is not available!!!', 'Website' );            }            // get browser languages            $_languages = $this->Env->httpAcceptLanguage();            //            if ( count( $_languages ) > 0 )            {                $langfallback  = " AND (baselang IN('" . implode( "','", $_languages ) . "') OR languagefallback=1)";                $languageOrder = ", baselang = '" . implode( "' DESC, baselang = '", $_languages ) . "' DESC";            }            else            {                $langfallback  = " AND languagefallback=1";                $languageOrder = '';            }            $accessquery = '';            /*              if (!User::isLoggedIn())              {              $accessquery = " AND (publishon=0 OR publishon<$time) AND (publishoff=0 OR publishoff>$time) AND published=1";              }             */            $Page = Cache::get( 'websiteconfig-' . INSTALL_ID, '' );            if ( !is_array( $Page ) )            {                $sql = "SELECT * FROM %tp%websites WHERE (domains LIKE '%" . $domain . "%' OR domains='')                                  " . $langfallback . $accessquery . " ORDER BY domains DESC                                  " . $languageOrder . " LIMIT 1";                // Find the matching root pages                $Page = $this->db->query( $sql )->fetch();                if ( !empty( $Page[ 'id' ] ) )                {                    Cache::write( 'websiteconfig-' . INSTALL_ID, $Page, '' );                }                $this->db->free();            }            if ( empty( $Page[ 'id' ] ) )            {                Library::log( 'Website not exists! Please Contact the Administrator of this Domain an report this Error ("Bad Domain Configuration.")', 'error', array('sql' => $sql) );                trigger_error( 'Website not exists! Please Contact the Administrator of this Domain an report this Error ("Bad Domain Configuration.")', E_USER_ERROR );            }            $GLOBALS[ 'WEBSITE' ] = $Page;            /**             *             */            define( 'SERVER_PAGE', '' . (int)$Page[ 'id' ] );            /**             *             */            define( 'PAGEID', '' . SERVER_PAGE );            /**             *             */            define( 'PAGE_PATH', PUBLIC_PATH . 'pages/' . PAGEID . '/' );            /**             *             */            define( 'PAGE_URL_PATH', 'public/pages/' . PAGEID . '/' );            // @fixed            #		define('INSTALL_ID', md5(PAGEID . $Page[ 'domainname' ]) . ($this->_applicationMode === self::FRONTEND_MODE ?            #				'_fe' : '_be'));        }        else        {            $GLOBALS[ 'WEBSITE' ] = array(); // default is empty ????            /**             *             */            define( 'SERVER_PAGE', '' . self::DEFAULT_PAGEFOLDER );            /**             *             */            define( 'PAGEID', SERVER_PAGE );            /**             *             */            define( 'PAGE_PATH', PUBLIC_PATH . 'pages/' . PAGEID . '/' );            /**             *             */            define( 'PAGE_URL_PATH', 'public/pages/' . PAGEID . '/' );            // @fixed            #		define('INSTALL_ID', md5(PAGEID . $domain) . ($this->_applicationMode === self::FRONTEND_MODE ? '_fe' :            #				'_be'));        }        // Caching        /**         *         */        define( 'PAGE_CACHE_PATH', PAGE_PATH . '.cache/' );        /**         *         */        define( 'PAGE_CACHE_URL', PAGE_URL_PATH . '.cache/' );        /**         *         */        define( 'IMAGE_CACHE', PAGE_PATH . '.cache/thumbnails/' );        /**         *         */        define( 'MEDIA_PATH', PAGE_PATH . 'media/' );        /**         *         */        $cfg = array();        include PAGE_PATH . '.config.php';        // disable database profiling        if ( ( defined( 'DEBUG' ) && !DEBUG ) )        {            $this->db->enableProfiler = false;        }        // register the session timeout global        if ( $this->_applicationMode === self::FRONTEND_MODE )        {            $GLOBALS[ 'SESSIONTIMEOUT' ] = (int)$cfg[ 'usersession_timeout' ] > 0 ? $cfg[ 'usersession_timeout' ] : 3600;        }        else        {            $GLOBALS[ 'SESSIONTIMEOUT' ] = (int)$cfg[ 'adminsession_timeout' ] > 0 ? $cfg[ 'adminsession_timeout' ] : 3600;        }        // init the session        Session::getInstance();        # $this->load( 'Session' );        // config is only writeable in the backend        $this->_systemConfig = new Config( $cfg, ( $this->_applicationMode === self::FRONTEND_MODE ? false : true ) );        // Clear Included Config        unset( $cfg );        // define the default content language        /**         *         */        define( 'DEFAULT_CONTENT_LANG', Locales::getShortLocaleFromCode( Settings::get( 'locale', 'de' ) ) );        // Clear Page result        $Page = null;        // Set the Website Cache path        Cache::setCachePath( PAGE_CACHE_PATH );        /**         *         */        define( 'IMAGEMAGICK_PATH', Settings::get( 'imagemagick_path', '' ) ); // @todo remove imagemagick_path        $uploadpath = Settings::get( 'upload_dir', 'upload' );        /**         *         */        define( 'UPLOAD_PATH', ROOT_PATH . 'public/pages/' . PAGEID . '/' . $uploadpath . '/' );        /**         *         */        define( 'UPLOAD_URL', Settings::get( 'portalurl' ) . '/pages/' . PAGEID . '/' . $uploadpath . '/' );        $this->registerModules();        /**         * Patch 14.02.2014         *         * the backend was broken when change a modul publishing/installing or uninstalling         */        $this->loadFrontendModules();        $this->load( 'Hook' ); // init Hooks only        $this->load( 'GUI' );        $this->load( 'Site' );        // load routes only for the frontend        if ( $this->_applicationMode !== self::BACKEND_MODE )        {            $this->initRoutes();        }        if ( HTTP::input( 'setcontenttranslation' ) > 0 )        {            $translate = Locales::getLocaleById( HTTP::input( 'setcontenttranslation' ) );            $trans     = $translate[ 'lang' ];            Session::save( 'trans_code', $trans );            //Library::sendJson(false, print_r($translate, true) );        }        if ( !Session::get( 'WEBSITE_ID' ) )        {            Session::save( 'WEBSITE_ID', SERVER_PAGE );            //     Session::save( 'WEBSITE_DATA', $GLOBALS[ 'WEBSITE' ] );        }        // Setup Content language and GUI language        $this->setupLanguages();        if ( !Session::get( 'login_ip' ) )        {            Session::save( 'login_ip', $this->Env->ip() );        }        Session::save( 'trans_code', CONTENT_TRANS );        if ( !defined( 'ADM_SCRIPT' ) )        {            $timeout = time() + $GLOBALS[ 'SESSIONTIMEOUT' ];            @setcookie( 'DREAMCMS_FE_WEBSITE', PAGEID, $timeout, '/' );        }        /*         * Ist es eine demonstration der DreamCMS installation         * Its a demonstation of the DreamCMS installation         */        if ( defined( 'DEMOADMINID' ) && ( User::getUserId() === DEMOADMINID ) )        {            /**             *             */            define( 'DEMO_MODE', true );            /**             *             */            define( 'DEMO_MODE_USERID', User::getUserId() );        }        if ( $this->isFrontend() )        {            if ( $this->input( 'seemode' ) === 'on' )            {                Session::save( 'seemode', true );            }            else if ( $this->input( 'seemode' ) === 'off' )            {                Session::save( 'seemode', false );            }            else            {                if ( User::isAdmin() && Session::save( 'seemode', null ) === null )                {                    Session::save( 'seemode', true );                }            }        }        // set the website hash        Cookie::set( 'SITE', INSTALL_ID );        $GLOBALS[ 'WEB_INIT' ] = true;        Hook::run( 'onAfterSetupWebsiteByDomain' ); // {CONTEXT:Framework , DESC:Run code after Website setup is complete}        User::getUserId();        if ( $this->_applicationMode === self::BACKEND_MODE )        {            $this->registerBackendMenues();        }        return $this;    }    /**     *     */    private function setupLanguages()    {        $trans = null;        if ( HTTP::input( 'setlocale' ) )        {            $translate = HTTP::getClean( HTTP::input( 'setlocale' ), true );            /* Change the Content language only */            $trans = Locales::getShortLocaleFromCode( $translate );            Session::save( 'trans_code', $trans );            Cookie::set( 'trans_code', $trans );            // Set automaticly the GUI language to the content language            if ( $this->getMode() === Application::FRONTEND_MODE )            {                $locale = $this->GUI->getAutoDetectedLanguage();                $list = explode( '_', $locale );                if ( $list[ 0 ] && $list[ 0 ] !== $trans )                {                    $code      = Locales::getLocaleFromLang( $trans );                    $available = $this->GUI->getAvailableLanguages();                    // @todo force set the gui language if change the content language?                    if ( isset( $available[ $code ] ) )                    {                        Cookie::set( 'guilang', $code );                    }                }            }            if ( IS_AJAX )            {                //Session::write();                Library::sendJson( true );            }        }        if ( HTTP::input( 'translate' ) && $this->input( 'adm' ) != 'locale' )        {            $translate = HTTP::getClean( HTTP::input( 'translate' ), true );            /* Change the Content language only */            $trans = Locales::getShortLocaleFromCode( $translate );            Session::save( 'trans_code', $trans );            Cookie::set( 'trans_code', $trans );            if ( IS_AJAX )            {                //Session::write();                Library::sendJson( true );            }        }        if ( $this->_post( 'settranslation' ) )        {            Session::save( 'trans_code', $this->_post( 'settranslation' ) );            Cookie::set( 'trans_code', Session::get( 'trans_code' ) );        }        if ( Session::get( 'trans_code' ) )        {            $trans = Session::get( 'trans_code' );        }        elseif ( Cookie::get( 'trans_code' ) )        {            $trans = Locales::getShortLocaleFromCode( Cookie::get( 'trans_code' ) );        }        else        {            $trans = ( $GLOBALS[ 'WEBSITE' ][ 'baselang' ] !== '' ? $GLOBALS[ 'WEBSITE' ][ 'baselang' ] : 'de' );        }        if ( !$trans && DEFAULT_CONTENT_LANG )        {            $trans = DEFAULT_CONTENT_LANG;        }        $GLOBALS[ 'WEBSITE' ][ 'baselang' ] = $trans;        /**         *         */        define( 'CONTENT_TRANS', $trans );        $this->initGuiLanguage();    }    /**     *     * @return array the database result     */    public function getContentTranslation()    {        static $_locale;        if ( Session::get( 'trans_code' ) )        {            $trans = Session::get( 'trans_code' );        }        elseif ( Cookie::get( 'trans_code' ) )        {            $trans = Locales::getShortLocaleFromCode( Cookie::get( 'trans_code' ) );        }        else        {            $trans = ( $GLOBALS[ 'WEBSITE' ][ 'language' ] !== '' ? $GLOBALS[ 'WEBSITE' ][ 'language' ] : $GLOBALS[ 'WEBSITE' ][ 'lang' ] );        }        if ( isset( $_locale[ $trans ] ) )        {            return $_locale[ $trans ];        }        $_locale[ $trans ] = Locales::getLocaleByLang( $trans );        return $_locale[ $trans ];    }    /**     *     * @return Application     */    public function initGuiLanguage()    {        if ( HTTP::input( 'setguilang' ) )        {            $locale = HTTP::getClean( HTTP::input( 'setguilang' ), true );            Session::save( 'guilang', $locale );            Cookie::set( 'guilang', $locale );        }        $locale = Cookie::get( 'guilang' );        // detect automaticly the gui language. based on the browser languages.        if ( $this->getMode() === Application::FRONTEND_MODE && !$locale && !HTTP::input( 'setguilang' ) )        {            $locale = $this->GUI->getAutoDetectedLanguage();        }        $locale = is_string( $locale ) && $locale !== '' ? $locale : Session::get( 'guilang' );        $locale = is_string( $locale ) && $locale !== '' ? $locale : Settings::get( 'locale', 'de_DE' );        $textDomain = 'DreamCMS';        // Gui language fallback        if ( !is_file( I18N_PATH . $locale . '/LC_MESSAGES/' . $textDomain . '.mo' ) && !is_file( I18N_PATH . $locale . '/LC_MESSAGES/' . $textDomain . '.po' ) )        {            $locale = 'de_DE';        }        putenv( 'LC_ALL=' . $locale );        putenv( 'LC_MESSAGES=' . $locale );        Library::disableErrorHandling();        date_default_timezone_set( date_default_timezone_get() );        Library::enableErrorHandling();        //        if ( !function_exists( 'setlocale' ) )        {            T_setlocale( LC_ALL, $locale );            T_bindtextdomain( $textDomain, substr( I18N_PATH, 0, -1 ) );            T_bind_textdomain_codeset( $textDomain, 'UTF8' );            T_textdomain( $textDomain );        }        else        {            setlocale( LC_ALL, $locale );            bindtextdomain( $textDomain, substr( I18N_PATH, 0, -1 ) );            textdomain( $textDomain );            bind_textdomain_codeset( $textDomain, 'UTF8' );        }        Session::save( 'guilang', $locale );        $GLOBALS[ 'GUI_LOCALE' ] = $locale;        /**         *         */        if ( !defined( 'GUI_LANGUAGE' ) )        {            /**             *             */            define( 'GUI_LANGUAGE', $locale );        }        Locales::_init( $locale ); // reload locale        // set the correct timezone        // Localization::setDefaultTimezone();        // unbelievable! the following actually works!        // Session::save('guilang', $locale);        // Enum => Translation        $GLOBALS[ 'usergroupTypes' ] = array(            'administrator' => trans( 'System Administrator' ),            'chefredakteur' => trans( 'Chefredakteur' ),            'author'        => trans( 'Autor' ),            'default'       => trans( 'Benutzer' ),            'guest'         => trans( 'Gäste' ),        );        $locale = null;        return $this;    }    public function ajaxRun()    {        $this->run( true );    }    /**     * @return Fileman_Helper_Index     */    public static function getIndexerInstance()    {        $indexer = new Fileman_Helper_Index();        $indexer->setIndexBasePath( PAGE_PATH );        $indexer->addExclude( PAGE_CACHE_PATH )            ->addExclude( PAGE_PATH . '.tmb/' )            ->addExclude( '.DS_Store' )            ->addExclude( '.htaccess' )            ->addExclude( '.htpasswd' )            ->addExclude( '.config.php' )            //	->addExclude('.md')            //	->addExclude('.svn')            //	->addExclude('.git')            ->addExclude( 'Thumbs.db' );        return $indexer;    }    /**     *     */    public function run($ajax = false)    {        // Firewall check and Stop if found BAD request        if ( defined( 'USE_FIREWALL' ) && USE_FIREWALL )        {            $this->load( 'Firewall' );            $this->Firewall->initFirewall()->run();            $this->unload( 'Firewall' );        }        /*                if ( class_exists('Fileman_Helper_Index'))                {                    $indexer = new Fileman_Helper_Index();                    $indexer->setIndexBasePath(PAGE_PATH);                    $indexer->addExclude(PAGE_CACHE_PATH)                        ->addExclude(PAGE_PATH .'.tmb/')                        ->addExclude('.DS_Store')                        ->addExclude('.htaccess')                        ->addExclude('.htpasswd')                        ->addExclude('.config.php')                    //	->addExclude('.md')                    //	->addExclude('.svn')                    //	->addExclude('.git')                        ->addExclude('Thumbs.db');                    $indexer->updateIndex();                }        */        Hook::run( 'onBeforeRunApplication' ); // {CONTEXT:Framework, DESC: Execute extra scripts and code before run the Application}        /**         * Run CSRF check         *         * if ( $this->Input->getMethod() == 'post' )         * {         * $post = $this->_post();         *         * if ( !empty( $post ) && !Csrf::checkCSRF('token', $post, true, $GLOBALS[ 'SESSIONTIMEOUT' ], true) )         * {         * $this->load('Page');         * $this->Page->send404('Invalid Form');         * exit;         * }         * }         */        $this->load( 'Controller' );        $this->Controller->runController( $ajax );    }}?>